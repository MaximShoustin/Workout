#!/usr/bin/env python3
"""
Workout CLI - Command Line Interface for Workout Generation
===========================================================

A comprehensive CLI tool for generating, managing, and tracking workouts.

Usage:
    ./workout                    # Generate a new workout
    ./workout -status           # List all existing exercises
    ./workout -help             # Show this help message
    ./workout -add              # Add a new exercise to the database
    ./workout -edit <ids>       # Edit specific exercises by ID (comma-separated)
    ./workout -include <ids>    # Include specific exercises by ID (comma-separated)

Examples:
    ./workout -status
    ./workout -edit 101,102,103
    ./workout -include 88,94,96
    ./workout -add
"""

import sys
import argparse
import json
from pathlib import Path
from typing import List, Dict, Set

# Add current directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

from config import load_json, EQUIP_DIR
from equipment import parse_equipment, build_station_pool
from html_generator import format_exercise_link


def show_help():
    """Display comprehensive help information."""
    help_text = """
üèãÔ∏è  WORKOUT CLI - Command Line Interface
========================================

USAGE:
    ./workout [COMMAND] [OPTIONS]

COMMANDS:
    (no command)        Generate a new workout with current settings
    -status            List all existing exercises in the database
    -view-all          Generate HTML table of all exercises
    -manual            Manually create a workout by selecting exercises (interactive)
    -help              Show this help message
    -add               Add a new exercise to the database (interactive)
    -edit <ids>        Edit specific exercises in current workout by ID
    -include <ids>     Force include specific exercises by ID in new workout

OPTIONS for -edit and -include:
    <ids>              Comma-separated list of exercise IDs (e.g., 101,102,103)

EXAMPLES:
    ./workout                     # Generate new workout
    ./workout -status             # List all exercises
    ./workout -view-all           # Generate HTML table of all exercises
    ./workout -manual             # Manually select exercises for each station
    ./workout -help               # Show this help
    ./workout -add                # Add new exercise (interactive)
    ./workout -edit 101,102       # Replace exercises 101,102 in current workout
    ./workout -include 88,94,96   # Force include exercises 88,94,96 in new workout

CONFIGURATION:
    Edit config/plan.json to customize:
    - Number of stations and people
    - Equipment inventory
    - Active rest settings
    - Balance order (upper/lower/core)
    - Exercise history tracking

FILES:
    config/plan.json             Main configuration file
    equipment/*.json             Exercise databases by equipment type
    index.html                   Generated workout display
    workout_store/               Workout history and data

For more information, see README.md
"""
    print(help_text)


def get_all_exercises() -> List[Dict]:
    """Get all exercises from all equipment files."""
    all_exercises = []
    
    # Parse equipment to get all exercises
    try:
        gear = parse_equipment()
        station_pool = build_station_pool(gear)
        
        # Convert tuples to dictionaries for easier handling
        for exercise_tuple in station_pool:
            area, equip_name, exercise_name, exercise_link, equipment_data, muscles, unilateral, exercise_id, video_type = exercise_tuple
            
            exercise_dict = {
                'id': exercise_id,
                'name': exercise_name,
                'area': area,
                'equipment': equip_name,
                'muscles': muscles,
                'unilateral': unilateral,
                'link': exercise_link,
                'video_type': video_type,
                'equipment_requirements': equipment_data
            }
            all_exercises.append(exercise_dict)
    
    except Exception as e:
        print(f"‚ùå Error loading exercises: {e}")
        return []
    
    return all_exercises


def generate_exercises_html():
    """Generate HTML file with table of all available exercises."""
    from datetime import datetime
    from pathlib import Path
    import webbrowser
    
    print("üèãÔ∏è  GENERATING EXERCISES HTML TABLE")
    print("=" * 50)
    print()
    
    exercises = get_all_exercises()
    
    if not exercises:
        print("‚ùå No exercises found in database.")
        return
    
    # Sort exercises by ID (smallest to greatest), with -1 IDs at the end
    exercises.sort(key=lambda x: (x['id'] if x['id'] != -1 else 99999, x['name']))
    
    # Group exercises by area
    by_area = {}
    for exercise in exercises:
        area = exercise['area']
        if area not in by_area:
            by_area[area] = []
        by_area[area].append(exercise)
    
    # Generate timestamp for filename
    timestamp = datetime.now().strftime("%d-%m-%Y-%H-%M-%S")
    filename = f"EXERCISES_{timestamp}.html"
    filepath = Path("workout_store") / filename
    
    # Ensure workout_store directory exists
    Path("workout_store").mkdir(exist_ok=True)
    
    # Generate HTML content
    # For root: use relative paths to config/pictures
    html_content_root = generate_exercises_html_content(
        by_area, exercises, 
        pictures_path="config/pictures"
    )
    
    # For workout_store: use relative paths going up one level to config/pictures
    html_content_store = generate_exercises_html_content(
        by_area, exercises,
        pictures_path="../config/pictures"
    )
    
    # Save to file in workout_store (with relative paths to ../...)
    with filepath.open('w', encoding='utf-8') as f:
        f.write(html_content_store)
    
    # Also save to exercises.html in project root (with paths to config/pictures)
    exercises_path = Path("exercises.html")
    with exercises_path.open('w', encoding='utf-8') as f:
        f.write(html_content_root)
    
    print(f"‚úÖ Exercises HTML saved to: {filepath}")
    print(f"üåê Also saved to: exercises.html")
    print(f"üìä Total exercises: {len(exercises)}")
    print(f"üéØ Areas covered: {', '.join(sorted(by_area.keys()))}")
    print()
    
    # Open the HTML file in the default browser
    print("üåê Opening exercises.html in browser...")
    webbrowser.open(f"file://{exercises_path.absolute()}")
    print("‚úÖ Browser opened!")


def generate_exercises_html_content(by_area: dict, all_exercises: list, pictures_path: str = "config/pictures", css_path: str = "static/css/exercises.css", js_path: str = "static/js/exercises.js") -> str:
    """Generate the HTML content for exercises table using static templates."""
    from datetime import datetime
    from pathlib import Path as PathLib
    
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    total_exercises = len(all_exercises)
    
    # Count exercises by area
    area_counts = {area: len(exercises) for area, exercises in by_area.items()}
    
    # Load the HTML template
    template_path = PathLib("static/templates/exercises_template.html")
    with template_path.open('r', encoding='utf-8') as f:
        html_template = f.read()
    
    # Load CSS and JS content to inline them
    css_file_path = PathLib(css_path)
    with css_file_path.open('r', encoding='utf-8') as f:
        css_content = f.read()
    
    js_file_path = PathLib(js_path)
    with js_file_path.open('r', encoding='utf-8') as f:
        js_content = f.read()
    
    # Build stats content
    stats_html = f"""
                <div class="stat">
                    <span class="stat-number">{total_exercises}</span>
                    <span class="stat-label">Total Exercises</span>
                </div>"""
    
    # Add area stats
    for area, count in sorted(area_counts.items()):
        area_emoji = {"upper": "üí™", "lower": "ü¶µ", "core": "üî•"}.get(area, "üèãÔ∏è")
        stats_html += f"""
                <div class="stat">
                    <span class="stat-number">{count}</span>
                    <span class="stat-label">{area_emoji} {area.title()}</span>
                </div>"""
    
    # Generate sections for each area
    area_emojis = {"upper": "üí™", "lower": "ü¶µ", "core": "üî•"}
    exercises_html = ""
    
    for area in sorted(by_area.keys()):
        exercises = by_area[area]
        area_emoji = area_emojis.get(area, "üèãÔ∏è")
        
        exercises_html += f"""
        <div class="area-section">
            <h2 class="area-title">{area_emoji} {area.upper()} ({len(exercises)} exercises)</h2>
            <div class="exercises-grid">"""
        
        for exercise in exercises:
            # For the exercises view, we want to display images directly in cards
            # So we don't use format_exercise_link which adds popup images
            exercise_name = exercise['name']
            
            # Add video link if available
            if exercise['link'] and exercise['link'] != "some url" and exercise['link'].strip():
                exercise_name = f'<a href="{exercise["link"]}" target="_blank" class="exercise-link">{exercise_name}</a>'
            
            # Check if images exist for this exercise (single or multiple)
            image_html = ""
            card_class = "exercise-card"
            if exercise['id'] != -1:
                # First check for single image (original format)
                single_image_path = PathLib("config/pictures") / f"{exercise['id']}.png"
                
                # Then check for multiple images (new format: id_1.png, id_2.png, etc.)
                multiple_images = []
                for i in range(1, 4):  # Check for up to 3 images (_1, _2, _3)
                    multi_image_path = PathLib("config/pictures") / f"{exercise['id']}_{i}.png"
                    if multi_image_path.exists():
                        multiple_images.append(f"{pictures_path}/{exercise['id']}_{i}.png")
                
                if multiple_images:
                    # Use multiple images
                    images_html = ""
                    for img_src in multiple_images:
                        images_html += f'<img src="{img_src}" alt="{exercise["name"]}" onerror="this.style.display=\'none\'">'
                    image_html = f'<div class="exercise-images">{images_html}</div>'
                elif single_image_path.exists():
                    # Use single image (backward compatibility)
                    image_html = f'<img src="{pictures_path}/{exercise["id"]}.png" alt="{exercise["name"]}" class="exercise-image" onerror="this.style.display=\'none\'">'
                else:
                    card_class = "exercise-card no-image"
            else:
                card_class = "exercise-card no-image"
            
            # Format muscles list
            muscles = exercise['muscles']
            if isinstance(muscles, list):
                muscles_str = ', '.join(muscles)
            else:
                muscles_str = muscles
            
            # Truncate long muscle lists
            if len(muscles_str) > 50:
                muscles_str = muscles_str[:47] + "..."
            
            # Equipment display name
            equipment_display = exercise['equipment'].replace('_', ' ').title()
            
            unilateral_badge = '<span class="unilateral-badge">U</span>' if exercise['unilateral'] else ''
            
            exercises_html += f"""
                <div class="{card_class}">
                    {image_html}
                    <div class="exercise-content">
                        <div class="exercise-details">
                            <div class="exercise-header">
                                <div class="exercise-id">{exercise['id'] if exercise['id'] != -1 else '--'}</div>
                                <div class="exercise-name">
                                    {exercise_name}{unilateral_badge}
                                </div>
                            </div>
                            <div class="exercise-muscles">{muscles_str}</div>
                        </div>
                    </div>
                </div>"""
        
        exercises_html += """
            </div>
        </div>"""
    
    # Replace placeholders in template with actual content
    html = html_template.replace("{{CSS_CONTENT}}", css_content)
    html = html.replace("{{JS_CONTENT}}", js_content)
    html = html.replace("{{TIMESTAMP}}", timestamp)
    html = html.replace("{{STATS_CONTENT}}", stats_html)
    html = html.replace("{{EXERCISES_CONTENT}}", exercises_html)
    
    return html


def show_status():
    """Display status of all existing exercises."""
    print("üìä WORKOUT DATABASE STATUS")
    print("=" * 50)
    print()
    
    exercises = get_all_exercises()
    
    if not exercises:
        print("‚ùå No exercises found in database.")
        return
    
    # Group exercises by area and equipment
    by_area = {}
    by_equipment = {}
    
    for exercise in exercises:
        area = exercise['area']
        equipment = exercise['equipment']
        
        if area not in by_area:
            by_area[area] = []
        by_area[area].append(exercise)
        
        if equipment not in by_equipment:
            by_equipment[equipment] = []
        by_equipment[equipment].append(exercise)
    
    # Summary statistics
    total_exercises = len(exercises)
    valid_id_exercises = len([ex for ex in exercises if ex['id'] != -1])
    unilateral_exercises = len([ex for ex in exercises if ex['unilateral']])
    
    print(f"üìà SUMMARY:")
    print(f"   Total Exercises: {total_exercises}")
    print(f"   With Valid IDs:  {valid_id_exercises}")
    print(f"   Unilateral:      {unilateral_exercises}")
    print(f"   Areas:           {len(by_area)}")
    print(f"   Equipment Types: {len(by_equipment)}")
    print()
    
    # Show exercises by area
    print("üéØ BY AREA:")
    print("-" * 30)
    for area in sorted(by_area.keys()):
        exercises_in_area = by_area[area]
        print(f"  {area.upper()} ({len(exercises_in_area)} exercises):")
        
        # Sort by ID for consistent display
        exercises_in_area.sort(key=lambda x: x['id'] if x['id'] != -1 else 9999)
        
        for exercise in exercises_in_area:
            id_str = f"ID:{exercise['id']:3d}" if exercise['id'] != -1 else "ID: --"
            unilateral_str = " [U]" if exercise['unilateral'] else "    "
            equipment_str = f"({exercise['equipment']})"
            print(f"    {id_str}{unilateral_str} {exercise['name']:<35} {equipment_str}")
        print()
    
    # Show exercises by equipment
    print("üõ†Ô∏è  BY EQUIPMENT:")
    print("-" * 30)
    for equipment in sorted(by_equipment.keys()):
        exercises_with_equipment = by_equipment[equipment]
        print(f"  {equipment.upper().replace('_', ' ')} ({len(exercises_with_equipment)} exercises):")
        
        # Sort by ID for consistent display
        exercises_with_equipment.sort(key=lambda x: x['id'] if x['id'] != -1 else 9999)
        
        for exercise in exercises_with_equipment:
            id_str = f"ID:{exercise['id']:3d}" if exercise['id'] != -1 else "ID: --"
            unilateral_str = " [U]" if exercise['unilateral'] else "    "
            area_str = f"({exercise['area']})"
            print(f"    {id_str}{unilateral_str} {exercise['name']:<35} {area_str}")
        print()
    
    # Show exercises with missing IDs
    missing_id_exercises = [ex for ex in exercises if ex['id'] == -1]
    if missing_id_exercises:
        print("‚ö†Ô∏è  EXERCISES WITHOUT IDs:")
        print("-" * 30)
        for exercise in missing_id_exercises:
            unilateral_str = " [U]" if exercise['unilateral'] else "    "
            print(f"    {unilateral_str} {exercise['name']:<35} ({exercise['equipment']}, {exercise['area']})")
        print()
    
    print("üí° LEGEND:")
    print("   [U] = Unilateral exercise (requires left/right execution)")
    print("   ID  = Exercise ID for use with -edit and -include commands")
    print()


def create_manual_workout():
    """Interactively create a manual workout by specifying exercises for each station."""
    from config import load_json
    import webbrowser
    
    print("üèãÔ∏è  MANUAL WORKOUT CREATION")
    print("=" * 50)
    print()
    
    # Get all exercises for reference
    all_exercises_list = get_all_exercises()
    exercises_by_id = {ex['id']: ex for ex in all_exercises_list if ex['id'] != -1}
    
    if not exercises_by_id:
        print("‚ùå No exercises with valid IDs found in database.")
        return
    
    print(f"üìä Total exercises available: {len(exercises_by_id)}")
    print("üí° Tip: Use './workout -view-all' to see all exercises with their IDs")
    print()
    
    # Ask for number of stations
    while True:
        try:
            num_stations = input("How many stations do you want? ")
            num_stations = int(num_stations.strip())
            if num_stations <= 0:
                print("‚ùå Please enter a positive number.")
                continue
            break
        except ValueError:
            print("‚ùå Please enter a valid number.")
        except (KeyboardInterrupt, EOFError):
            print("\n‚ö†Ô∏è Manual workout creation cancelled.")
            sys.exit(0)
    
    print()
    print(f"‚úÖ Creating workout with {num_stations} stations")
    print()
    
    # Collect exercises for each station
    stations = []
    station_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    
    for i in range(num_stations):
        station_letter = station_letters[i] if i < len(station_letters) else f"Station {i+1}"
        print(f"üìç Station {station_letter}")
        print("-" * 40)
        
        while True:
            try:
                ids_input = input(f"   Enter exercise IDs for station {station_letter} (comma-separated): ")
                ids_input = ids_input.strip()
                
                if not ids_input:
                    print("   ‚ùå Please enter at least one exercise ID.")
                    continue
                
                # Parse IDs
                station_exercise_ids = parse_id_list(ids_input)
                
                # Validate IDs
                invalid_ids = [ex_id for ex_id in station_exercise_ids if ex_id not in exercises_by_id]
                if invalid_ids:
                    print(f"   ‚ùå Invalid exercise IDs: {invalid_ids}")
                    print(f"   üí° Use './workout -status' to see valid IDs")
                    continue
                
                # Build exercise list, expanding unilateral exercises into left/right
                station_exercises = []
                print(f"   ‚úÖ Selected exercises:")
                
                for ex_id in station_exercise_ids:
                    ex = exercises_by_id[ex_id]
                    
                    if ex.get('unilateral', False):
                        # Unilateral exercise - add both left and right
                        print(f"      ‚Ä¢ ID {ex_id}: {ex['name']} ({ex['area']}) [Unilateral - will create Left+Right]")
                        
                        # Create left side version
                        ex_left = ex.copy()
                        ex_left['name'] = f"{ex['name']} (Left)"
                        station_exercises.append(ex_left)
                        
                        # Create right side version
                        ex_right = ex.copy()
                        ex_right['name'] = f"{ex['name']} (Right)"
                        station_exercises.append(ex_right)
                    else:
                        # Regular exercise - add as is
                        print(f"      ‚Ä¢ ID {ex_id}: {ex['name']} ({ex['area']})")
                        station_exercises.append(ex)
                
                # Build station
                station = {
                    'station_letter': station_letter,
                    'exercises': station_exercises
                }
                stations.append(station)
                print()
                break
                
            except (KeyboardInterrupt, EOFError):
                print("\n‚ö†Ô∏è Manual workout creation cancelled.")
                sys.exit(0)
            except Exception as e:
                print(f"   ‚ùå Error: {e}")
                continue
    
    # Generate workout HTML
    print("üî® Generating workout HTML...")
    print()
    
    # Load plan for timing settings
    try:
        plan = load_json(Path("config/plan.json"))
        title = plan.get("title", "Manual Workout")
        
        # Generate HTML using our manual stations
        html_content = generate_manual_workout_html(plan, stations)
    except Exception as e:
        import traceback
        print(f"‚ùå Error during HTML generation: {e}")
        print("\nüìã Full traceback:")
        traceback.print_exc()
        sys.exit(1)
    
    # Save to file
    from datetime import datetime
    
    timestamp = datetime.now().strftime("%d-%m-%Y-%H-%M-%S")
    filename = f"WORKOUT_MANUAL_{timestamp}.html"
    filepath = Path("workout_store") / filename
    
    # Ensure workout_store directory exists
    Path("workout_store").mkdir(exist_ok=True)
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    # Also save to index.html in project root
    index_path = Path("index.html")
    with open(index_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    print(f"‚úÖ Manual workout saved to: {filepath}")
    print(f"üåê Also saved to: index.html")
    print(f"üìä Total stations: {num_stations}")
    print()
    
    # Open in browser
    print("üåê Opening workout in browser...")
    webbrowser.open(f"file://{index_path.absolute()}")
    print("‚úÖ Browser opened!")


def generate_manual_workout_html(plan: Dict, stations: List[Dict]) -> str:
    """Generate HTML for manually created workout."""
    from datetime import datetime
    from file_utils import save_workout_html
    from html_generator import generate_html_workout
    
    # Convert our manual stations format to the format expected by HTML generator
    formatted_stations = []
    
    for station in stations:
        # Determine the dominant area for this station (use first exercise's area)
        station_area = station['exercises'][0]['area'] if station['exercises'] else 'core'
        
        formatted_station = {
            'station_letter': station['station_letter'],
            'area': station_area  # Add station-level area field
        }
        
        # Add each exercise as a step (using EXACT same keys as regular workout)
        for step_num, exercise in enumerate(station['exercises'], 1):
            formatted_station[f'step{step_num}'] = exercise['name']  # Use step1, step2, not step1_exercise
            formatted_station[f'step{step_num}_link'] = exercise.get('link', '')
            formatted_station[f'step{step_num}_id'] = exercise['id']
            formatted_station[f'step{step_num}_equipment'] = exercise['equipment_requirements']
            formatted_station[f'step{step_num}_muscles'] = exercise['muscles']
            # Use None instead of '' for video_type so auto-detection works
            video_type = exercise.get('video_type', '')
            formatted_station[f'step{step_num}_video_type'] = video_type if video_type else None
        
        formatted_stations.append(formatted_station)
    
    # Update plan with actual number of steps
    max_steps = max(len(station['exercises']) for station in stations) if stations else 1
    plan['steps_per_station'] = max_steps
    
    # Calculate equipment requirements from all exercises
    equipment_requirements = {}
    people_per_station = plan.get('people_per_station', 1)
    
    for station in formatted_stations:
        step_num = 1
        while True:
            equipment_key = f'step{step_num}_equipment'
            if equipment_key not in station:
                break
            
            step_equipment = station[equipment_key]
            if step_equipment:
                # Aggregate equipment counts
                for equip_type, equip_info in step_equipment.items():
                    count_needed = equip_info.get('count', 0) * people_per_station
                    if equip_type in equipment_requirements:
                        equipment_requirements[equip_type]['count'] += count_needed
                    else:
                        equipment_requirements[equip_type] = {
                            'count': count_needed,
                            'icon': equip_info.get('icon', '')
                        }
            
            step_num += 1
    
    # Load available inventory from plan.json
    available_inventory = {}
    equipment_config = plan.get('equipment', {})
    for eq_type, eq_data in equipment_config.items():
        if isinstance(eq_data, dict) and 'count' in eq_data:
            available_inventory[eq_type] = eq_data['count']
        elif isinstance(eq_data, int):
            available_inventory[eq_type] = eq_data
    
    # Create equipment validation summary
    validation_summary = {
        'is_valid': True,
        'issues': [],
        'utilization_by_type': {}
    }
    
    for equip_type, equip_info in equipment_requirements.items():
        required = equip_info['count']
        available = available_inventory.get(equip_type, 0)
        
        if available > 0:
            utilization_pct = (required / available) * 100
        else:
            utilization_pct = 0.0
            
        validation_summary['utilization_by_type'][equip_type] = {
            'required': required,
            'available': available,
            'utilization_pct': utilization_pct,
            'sufficient': required <= available
        }
        
        if required > available:
            validation_summary['is_valid'] = False
            validation_summary['issues'].append(
                f"Insufficient {equip_type}: need {required}, have {available}"
            )
    
    # Generate HTML with all parameters
    html = generate_html_workout(
        plan, 
        formatted_stations, 
        equipment_requirements=equipment_requirements,
        validation_summary=validation_summary,
        global_active_rest_schedule=None,
        selected_active_rest_exercises=None,
        selected_crossfit_path_exercises=None,
        is_workout_store=False
    )
    return html


def parse_id_list(id_string: str) -> List[int]:
    """Parse comma-separated list of exercise IDs."""
    try:
        ids = []
        for id_str in id_string.split(','):
            id_str = id_str.strip()
            if id_str:
                ids.append(int(id_str))
        return ids
    except ValueError:
        print(f"‚ùå Error: Invalid ID format '{id_string}'. Use comma-separated integers (e.g., 101,102,103)")
        sys.exit(1)


def validate_exercise_ids(ids: List[int]) -> List[int]:
    """Validate that exercise IDs exist in the database."""
    exercises = get_all_exercises()
    valid_ids = {ex['id'] for ex in exercises if ex['id'] != -1}
    
    validated_ids = []
    invalid_ids = []
    
    for exercise_id in ids:
        if exercise_id in valid_ids:
            validated_ids.append(exercise_id)
        else:
            invalid_ids.append(exercise_id)
    
    if invalid_ids:
        print(f"‚ö†Ô∏è  Warning: The following exercise IDs were not found: {invalid_ids}")
        print("   Use './workout -status' to see all available exercise IDs.")
        
        if not validated_ids:
            print("‚ùå Error: No valid exercise IDs provided.")
            sys.exit(1)
        
        print(f"‚úÖ Proceeding with valid IDs: {validated_ids}")
    
    return validated_ids


def main():
    """Main CLI entry point."""
    # Handle no arguments - generate workout
    if len(sys.argv) == 1:
        # Import and run main workout generation
        from main import main as workout_main
        workout_main()
        return
    
    # Parse command line arguments
    command = sys.argv[1].lower()
    
    if command in ['-h', '--help', '-help', 'help']:
        show_help()
    
    elif command in ['-s', '--status', '-status', 'status']:
        show_status()
    
    elif command in ['-v', '--view-all', '-view-all', 'view-all']:
        generate_exercises_html()
    
    elif command in ['-m', '--manual', '-manual', 'manual']:
        create_manual_workout()
    
    elif command in ['-a', '--add', '-add', 'add']:
        # Import and run exercise addition
        from exercise_manager import add_exercise_cli
        add_exercise_cli()
    
    elif command in ['-e', '--edit', '-edit', 'edit']:
        if len(sys.argv) < 3:
            print("‚ùå Error: -edit command requires exercise IDs.")
            print("   Usage: ./workout -edit <ids>")
            print("   Example: ./workout -edit 101,102,103")
            sys.exit(1)
        
        # Parse and validate IDs
        id_string = sys.argv[2]
        exercise_ids = parse_id_list(id_string)
        validated_ids = validate_exercise_ids(exercise_ids)
        
        print(f"üîÑ Editing exercises: {validated_ids}")
        
        # Set up arguments for main script
        sys.argv = ['main.py', '-edit', ','.join(map(str, validated_ids))]
        
        # Import and run main with edit mode
        from main import main as workout_main
        workout_main()
    
    elif command in ['-i', '--include', '-include', 'include']:
        if len(sys.argv) < 3:
            print("‚ùå Error: -include command requires exercise IDs.")
            print("   Usage: ./workout -include <ids>")
            print("   Example: ./workout -include 88,94,96")
            sys.exit(1)
        
        # Parse and validate IDs
        id_string = sys.argv[2]
        exercise_ids = parse_id_list(id_string)
        validated_ids = validate_exercise_ids(exercise_ids)
        
        print(f"üéØ Including exercises: {validated_ids}")
        
        # Set up arguments for main script
        sys.argv = ['main.py', '-include', ','.join(map(str, validated_ids))]
        
        # Import and run main with include mode
        from main import main as workout_main
        workout_main()
    
    else:
        print(f"‚ùå Error: Unknown command '{command}'")
        print("   Use './workout -help' to see available commands.")
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nüö´ Operation cancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        sys.exit(1)
